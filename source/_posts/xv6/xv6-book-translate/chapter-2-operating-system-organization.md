---
title: Chapter 2 操作系统组成
date: 2022-11-03 09:09:12
categories:
- xv6
- xv6-book中文翻译
---
# Chapter 2 操作系统组成
操作系统的一个关键要求就是要在同一时刻支持许多活动。例如，可以使用系统调用`fork`开始一个新的线程。操作系统必须在这些进程上时间共享计算机资源。例如，即使进程比 CPU 多，操作系统必须确保所有的进程都能运行。操作系统必须确保隔离这些进程。因此，如果一个进程有错误和失败，它不应该影响到那些不依赖它的进程。完全的隔离，也不行，因为进程间还需要保持一定的交互，pipline 是一个例子。因此操作系统必须满足三个需求，资源复用，隔离和交互。
 
本章概述了如何组织操作系统来实现这三个要求。其实实现的方式有很多，但本章聚焦于宏内核上的主流设计，这也被用于许多 UNIX 操作系统。本章还提供了 XV6 进程的概念，这是 XV6 中的隔离单元，以及 XV6 启动时创建的地一个进程。

XV6 运行于多核 RISC-V 微处理器上，大多数低层功能是专属于 RISC-V，RISC-V 是一个64位CPU，使用 LP64 编写，意味着这个C语言中 `long` 和 `pointers` 是 64 位的，而不是 32 位。本书假定读者在一些架构上做了机器语言级别的编程，并会介绍 RISC-V 提出的一些特有的概念。关于 RISC-V 有这些书籍。指令手册和特权指令手册。

在计算机上，CPU 是被硬件包围的，大多数硬件都是输入输出接口。XV6 是为 qemu 的`-machine virt` 编写的。这包括 RAM，包含引导代码的 ROM，屏幕和键盘的链接，和磁盘存储。

## 抽象物理资源
人们对操作系统的第一个问题是，为什么要使用它。是的，可以将系统调用实现为库程序可链接的库。这样的话，每个应用程序甚至能有自己需要的库。应用程序能够直接与硬件资源交互，并且用最好的方式来使用这些资源。一些嵌入式设备上的操作系统和实时操作系统是用这种方式组织的。

这种库的缺点是，如果不仅仅是一个应用程序在运行，这些应用程序必须正常运行。例如，每个应用程序必须周期性的让出 CPU 来让其他应用程序运行。这样一种时间共享的方案是OK 的，如果应用程序之间互相信任并且没有错误。更通常的情况是应用程序之间不会互相信任并且有错误，因此需要比这种合作方式更强一些的隔离性。

为了实现更强的隔离性，一种有效的方式是不允许应用程序直接访问硬件资源，而是把资源抽象成服务。例如，Unix 应用程序仅通过 `open`，`read`，`write`和`close` 系统调用交互。而不是直接从硬盘上读写。通过路径名为应用程序提供便利，允许操作系统管理磁盘。即使不考虑隔离，需要交互的应用程序也会发现，相较于直接使用硬盘，使用文件系统是一种更方便的抽象形式。

同样，UNIX 将选择 CPU，根据需要保存和回复寄存器透明。这样应用程序不需要关心时间共享的问题。这种透明话允许操作系统共享 CPU 即使一些程序无限循环。

另一个例子，UNIX 进程使用 `exec` 建立内存镜像，而不是直接使用物理内存。让操作系统决定将进程放在内存哪一块。如果内存紧张，操作系统还会将进程的数据保存到硬盘上。 `Exec` 还为用户提供存储可执行文件镜像到文件系统的便利。

UNIX 进程间的许多交互都是通过文件描述副进行的。文件描述符不仅抽象了许多细节，还定义了简单的交互方式。例如，如果 pipeline 的一端应用程序崩溃，内核将生成一个 end-of-file 的信号给 pipeline 的下一个进程。

系统调用是经过精心设计的，即满足了程序交互，又提供了强隔离性。UNIX 接口不是唯一抽象资源的方法，但被证明是一种很好的方法。

## 用户模式，特权模式和系统调用

强隔离性需要在应用程序和操作系统间有一个很明确的边界。如果一个应用程序错误，我们不希望操作系统也挂了或者其他应用程序也挂了。相反，操作系统应该清除这些失败的程序并且继续运行其他程序。为了实现这个强隔离性，操作系统必须让应用程序不能修改操作系统的数据和指令。应用程序也不能访问其他进程的内存区域。

CPU 为这种强隔离性提供了硬件支持。例如 RISC-V 有三种 CPU 运行模式。`machine mode`，`supervisor mod`，`user mode`。 机器模式的指令有所有的权限。CPU 从机器模式启动，i机器模式大多被用来配置计算机。XV6 在机器模式执行很少的代码然后切换到监管者模式。

监管者模式的 CPU 允许执行特权指令，例如，启用或禁用中断，读写保存页表的寄存器等等。如果一个应用程序尝试执行特权指令，CPU 不执行这个指令，而是切换到监管模式，让监管模式程序终止掉这个进程，因为他做了不该做的事。应用程序仅运行用户模式的指令，称为运行在用户空间。同样的，在监管者模式下运行特权指令被称为运行在内核空间。运行在内核空间的程序被成为内核。

一个应用程序想调用内核函数必须陷入内核。CPU 提供了特殊的指令将 CPU 从用户模式变为监管者模式，并在内核指定的入口陷入内核。（RISC-V 使用 ecall 指令）。一旦 CPU 且的换到检查者模式，内核能够检查系统调用参数，决定程序是否被允许执行这个操作，然后阻止或者执行。内核控制陷入监管者模式的入口是很重要的，如果应用程序能决定内核入口，恶意的应用程序能跳过参数检查。

## 内核组织结构

一个关键的问题是哪操作系统的哪一部分应该应该跑在监管者模式下（监管者模式太难打了，后文简称s-mod），一种可能是整个操作系统都驻留在 s-mod。这种方式称为`宏内核`。

这种组织方式下，整个操作系统运行在所有硬件权限下。很方便操作系统设计因为不需要决定哪一部分操作系统不需要全部的硬件权限。此外，操作系统的不同部分也更易于合作。例如，操作系统有一个缓冲区能在文件系统和虚拟内存间共享。

这种宏内核的组织方式的缺点在于系统不同部分的接口是混杂在一起的。因此，系统开发者很容易造成错误。在宏内核中，错误是致命的，因为在 s-mod 中错误会导致内核崩溃。如果内核崩溃，计算机会停止工作，上边运行的的应用程序也会失败。计算机必须重启。

为了减少内核错误的风险，OS 设计者能减少在 s-mod 下运行的代码，并以用户模式执行大部分操作系统。这种内核组织形式称为`微内核`。

图示是一个微内核设计，图中，文件系统以用户模式运行。OS 服务以进程的方式运行被成为服务。为了允许应用与文件系统交互，内核提供进程内部通信机制让两个用户态的进程通信。例如，如果一个应用程序比如 shell 想读写文件，他会发消息给文件系统并等待回应。

在微内核里，内核接口由很少的低层函数组成用于启动应用，发送消息，访问设备等等。这种组织方式允许内核相对简单，让操作系统大部分运行在用户态。

XV6 和大多数 UNIX 操作系统一样，是以宏内核的方式实现的。因此，XV6 的内核接口对应的就是操作系统接口，内核实现了一个完整的操作系统。进行 XV6 没有提供很多服务，他的内核也比很多微内核小，但在概念上是宏内核。

## Code: xv6 组织结构
xv6 的内核在 `kernel/` 子目录下。源码以文件组织，遵循粗略的模块化概念。内部模块接口定义在 `kernel/defs.h`。

## 进程概述

xv6 中的隔离单元是 `进程`。进程的抽象可以一个进程破坏或监视另一个进程，CPU，文件描述符等等。也能防止进程破坏内核本身。使得进程不能颠覆内核的隔离机制。内核实现进程抽象必须相当小心，因为有缺陷或者恶意的应用程序可能导致内核或者硬件做一些坏事。内核用来实现进程的机制包括
用户/监关 模式标签，地址空间和线程时间分片。

为了帮助加强隔离，抽象进程为应用程序提供了一种假象，让它拥有私有机器。提供了其他程序不可读写的私有的内存系统和地址空间。进程还提供程序有自己的 CPU 执行程序指令。

XV6 使用页表（硬件实现）为每个进程赋予他们自己的地址空间。RISC-V 页表翻译一个`虚拟地址`到`物理地址`。

XV6 为每个进程维护一个单独的页表，用于定义该进程的地址空间。如图所示，一个包含 `user memory` 的地址空间从虚拟地址 0 开始。首先是指令，然后是全局变量，然后是栈，最后是 heap 区域（用于 malloc）。有许多因素会限制进程地址空间的最大值: RISC-V 上指针是 64 位宽，硬件仅使用低39位用于查询页表。XV6 进使用其中 38 位。因此，最大的地址空间是2的38次方，即256G。这在 `kernel/rsicv.h` MAXVA 有定义。在地址空间顶部，XV6 预留了`trampoline` 和页映射的 `trapframe` 用于切换到内核，这会在第四章讲到。

XV6 内核为每个进程维护了许多状态，聚集在 `struct proc` 中`kernel/proc.h`。一个进程最重要的内核状态就是他的页表，内核栈和运行状态。我们使用符号 `p-> xxx` 指向 `proc` 结构中的元素。例如 `p->pagatable` 是只想进程的页表。

每个进程都有一个执行线程来执行进程的指令。一个线程能够被挂起然后恢复。为了透明的选择进程，内核挂起当前的进程然后恢复另一个线程。大多数线程中的状态存储在线程的栈中，每个进程有两个栈，用户栈和内核栈`p->kstack`。当进程执行用户指令时，仅使用用户栈，并且内核栈是空的。当进程进入内核时（系统调用或者中断），内核代码执行在内核栈上。当线程在内核栈运行时，用户栈仍然保留着数据，但是并不被使用。一个进程的主动使用用户栈和内核栈之间交替。内核栈是分离的并免受用户代码的影响，这样即使进程摧毁了用户栈也能运行（core dump!!!）。

一个进程能够通过 RISC-V 的 `ecall`指令进行系统调用。这个指令提供硬件特权等级改变程序计数器到内核入口。入口处的代码切换到内核栈然后执行实现该系统调用耳朵内核指令。当系统调用完成，内核切换到用户栈并通过 `sret` 指令返回到用户空间，降低硬件特权等级，回复执行系统调用后的指令。一个进程的线程能够在内核中阻塞等待 IO，然后当 IO 完成后恢复。
`p->state` 表示程序是被分配，等待运行，运行中，等待IO 还是退出。
`p->pagetable` 以 RISC-V 硬件期望的方式保存进程页表。XV6 让分页硬件在用户执行应用时使用进程的 `p->pagetable`。进程页表还记录了存储进程内存的物理页。

## Code: xv6 的启动和第一个进程

为了让 xv6 更具体，我们将概述内核如何启动的和运行的地一个程序。子章节将更消息的描述这个机制的实现细节。

当 RISC-V 计算机启动时，它自身初始化并且运行一个内存中只读区域的 `boot loader`。Boot loader 将加载 XV6 的内核到内存中，然后在机器模式下，CPU 在 `_entry (kernel/entry.S)` 处启动XV6。RISC-V 在页硬件禁用的方式下启动，虚拟地址直接映射到物理地址。

Loader 将内核加载到物理地址的 0x80000000 处。内核加载到 0x80000000 而不是 0xx 的原因是前边的要留给 IO 设备。

_entry 处的指令设置一个栈让 xv6 能够运行 C 代码。XV6 声明一个初始化的栈空间`stack0 `在 `statc.c (kernel/start.c)`。__entry 将栈指针寄存器 sp 指向 `stack0+4096` 的盏顶，因为 RISC-V 的栈是向下增长的。现在内核有栈空间了，_entry 就能调用 `start (kernel/start.c)` 的 C 代码。

`start` 函数进行一些仅在 m-mod 才允许的配置，然后切换到 s-mod。为了进入 s-mod，RISC-V 提供了 mret 指令。这个指令最常用于 s-mod 到 m-mod 调用之后的返回。`start` 并不从这个调用返回，而是设置一些东西，在 `mstatus` 寄存器中设置s-mod，通过把 `main` 函数的返回地址放入 `mepc` 寄存器来返回到 main 函数，通过将 0 写入页表寄存器 `stap` 来禁用虚拟地址翻译，and delegates all interrupts and exceptions to supervisor mode.（这句不会）。

在跳到 s-mod 之前，`start` 还要执行一个任务，对时钟芯片进行编程以产生时钟中断。有了这个，`start` 通过 `mret` 指令返回到 s-mod。这也将让程序计数器调到 `main (kernel/main.c)`。

当 main 函数初始化一系列的设备和子系统后，它通过调用 `userinit (kernel/proc.c)` 创建第一个进程。第一个进程是用 RISC-V 汇编写的小程序，`initcode.S (user/initcode.S)`，通过调用 `exec` 重新进入内核。就像我们第一章讲的那样，`exec` 使用新的程序，在这个例子中是 `init`，替换当前进程的内存和寄存器。一旦内核完成 `exec`，将返回用户空间的 `init` 进程。`Init (user/init.c)` 创建一个新的控制台并将其以文件描述符 0 1 2 的形式打开。然后在这个控制台中启动一个 shell。系统就启动了。

## Real world
在现实中，我们能找到宏内核和微内核。许多 UNIX 内核是宏内核。例如 Linux，尽管一些系统功能在用户层。像 L4，Minix 和 QNX 是微内核，并在嵌入式系统中广泛使用。
大多数操作系统有进程的概念，兵器大多数进程和 XV6 是相似的，现代操作系统还支持在一个进程中拥有多线程，允许一个线程利用多个 CPU。在一个进程中支持多线程设计相当多，XV6 还没有，包括潜在的一些接口变化，控制进程线程共享。
